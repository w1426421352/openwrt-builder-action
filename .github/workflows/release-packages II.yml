name: release-packages

on:
  workflow_dispatch:
    inputs:
      manual_override:
        description: "Enable manual mode? (true/false) | 是否启用手动模式"
        required: false
        default: "false"

      config_path:
        description: "Path to config file (ignored if manual mode), default: config.json | 配置文件路径"
        required: false
        default: "config.json"

      manual_repos:
        description: "Comma-separated owner/repo list (manual mode only) | 手动模式下的仓库列表（逗号分隔）"
        required: false
        default: ""

      manual_versions:
        description: "Comma-separated OpenWrt versions (e.g. 24.10,23.05) | 手动模式下版本列表"
        required: false
        default: ""

      manual_targets:
        description: "Comma-separated target archs (manual mode only) | 手动模式下的平台列表"
        required: false
        default: ""

jobs:
  prepare:
    name: Prepare Matrix
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.generate.outputs.matrix }}

    steps:
      - name: Checkout Self
        uses: actions/checkout@v4

      - name: Generate Matrix
        id: generate
        run: |
          set -euo pipefail

          # ------------------------------
          # Read workflow inputs
          # ------------------------------
          MANUAL="${{ github.event.inputs.manual_override }}"
          CONFIG_PATH="${{ github.event.inputs.config_path }}"
          MANUAL_REPOS="${{ github.event.inputs.manual_repos }}"
          MANUAL_VERS="${{ github.event.inputs.manual_versions }}"
          MANUAL_TGTS="${{ github.event.inputs.manual_targets }}"

          MANUAL_LC=$(echo "$MANUAL" | tr 'A-Z' 'a-z')

          # ------------------------------
          # Define complete target list
          # ------------------------------
          ALL_TARGETS=(
            "arm_cortex-a5_vfpv4"
            "arm_cortex-a7_neon-vfpv4"
            "arm_cortex-a8_vfpv3"
            "arm_cortex-a9"
            "arm_cortex-a9_vfpv3-d16"
            "arm_cortex-a9_neon"
            "arm_cortex-a15_neon-vfpv4"
            "aarch64_cortex-a53"
            "aarch64_cortex-a72"
            "aarch64_cortex-a76"
            "aarch64_generic"
            "mips_24kc"
            "mips_4kec"
            "mips_mips32"
            "mipsel_24kc"
            "mipsel_24kc_24kf"
            "mipsel_74kc"
            "mipsel_mips32"
            "mips64_octeonplus"
            "i386_pentium4"
            "x86_64"
          )

          repos_list=""
          versions_list=""
          targets_list=""

          # ------------------------------
          # Manual mode
          # ------------------------------
          if [ "$MANUAL_LC" = "true" ]; then

            # --- repos ---
            IFS=',' read -ra RARR <<< "$MANUAL_REPOS"
            for r in "${RARR[@]}"; do
              t=$(echo "$r" | xargs)
              [ -n "$t" ] && repos_list="$repos_list $t"
            done

            # --- versions ---
            IFS=',' read -ra VARR <<< "$MANUAL_VERS"
            for v in "${VARR[@]}"; do
              v1=$(echo "$v" | xargs)
              [ -n "$v1" ] && versions_list="$versions_list $v1"
            done

            # --- targets ---
            IFS=',' read -ra TARR <<< "$MANUAL_TGTS"
            for t in "${TARR[@]}"; do
              t1=$(echo "$t" | xargs)
              [ -n "$t1" ] && targets_list="$targets_list $t1"
            done

          else
            # ------------------------------
            # Automatic mode: read config file
            # ------------------------------
            if [ ! -f "$CONFIG_PATH" ]; then
              echo "Config file not found: $CONFIG_PATH"
              exit 1
            fi

            REPOS_JSON=$(jq -r '.repos // []' "$CONFIG_PATH")
            VERS_JSON=$(jq -r '.versions // []' "$CONFIG_PATH")
            TGTS_JSON=$(jq -r '.targets // {}' "$CONFIG_PATH")

            repos_list=$(echo "$REPOS_JSON" | jq -r '.[]' | xargs)
            versions_list=$(echo "$VERS_JSON" | jq -r '.[]' | xargs)

            for t in "${ALL_TARGETS[@]}"; do
              v=$(echo "$TGTS_JSON" | jq -r --arg T "$t" 'if has($T) then .[$T] else false end')
              [ "$v" = "true" ] && targets_list="$targets_list $t"
            done
          fi

          # ------------------------------
          # Normalize versions (pure number → openwrt-NNN)
          # ------------------------------
          norm_versions=""
          for v in $versions_list; do
            if [[ "$v" =~ ^openwrt- ]]; then
              norm_versions="$norm_versions $v"
            else
              norm_versions="$norm_versions openwrt-$v"
            fi
          done
          versions_list=$(echo "$norm_versions" | xargs)

          # ------------------------------
          # Check
          # ------------------------------
          [ -z "$repos_list" ] && { echo "No repos"; exit 1; }
          [ -z "$versions_list" ] && { echo "No versions"; exit 1; }
          [ -z "$targets_list" ] && { echo "No targets"; exit 1; }

          # ------------------------------
          # Produce matrix.include
          # ------------------------------
          includes=()
          for repo in $repos_list; do
            owner=$(echo "$repo" | cut -d'/' -f1)
            repo_name=$(echo "$repo" | cut -d'/' -f2-)
            sanitized=$(echo "$repo" | tr '/' '-')

            for ver in $versions_list; do
              for arch in $targets_list; do
                item=$(jq -n \
                  --arg repo "$repo" \
                  --arg owner "$owner" \
                  --arg rname "$repo_name" \
                  --arg sanitized "$sanitized" \
                  --arg ver "$ver" \
                  --arg arch "$arch" \
                  '{repo:$repo, owner:$owner, repo_name:$rname, sanitized:$sanitized,
                    version:$ver, arch:$arch}')
                includes+=("$item")
              done
            done
          done

          matrix=$(printf '%s\n' "${includes[@]}" | jq -s '{include: .}')
          echo "matrix=$matrix" >> $GITHUB_OUTPUT
  release:
    name: Release (build)
    needs: prepare
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.prepare.outputs.matrix) }}
    steps:
      - name: Checkout self repo
        uses: actions/checkout@v4

      - name: Checkout plugin repo
        uses: actions/checkout@v4
        with:
          repository: ${{ matrix.repo }}
          path: plugin_repo

      - name: Gather repo info (commit/branch/description/release)
        id: repo_info
        run: |
          set -euo pipefail
          cd plugin_repo || exit 1

          # commit & branch
          COMMIT=$(git rev-parse --short HEAD 2>/dev/null || echo "")
          BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "")

          echo "commit=$COMMIT" >> $GITHUB_OUTPUT
          echo "branch=$BRANCH" >> $GITHUB_OUTPUT

          # Query GitHub API for description / latest release if token available
          OWNER="${{ matrix.owner }}"
          REPO_NAME="${{ matrix.repo_name }}"
          API="https://api.github.com/repos/${OWNER}/${REPO_NAME}"
          TOKEN="${{ secrets.GITHUB_TOKEN || '' }}"

          if [ -n "$TOKEN" ]; then
            DESC=$(curl -s -H "Authorization: token $TOKEN" "$API" | jq -r '.description // ""' 2>/dev/null || echo "")
            LATEST=$(curl -s -H "Authorization: token $TOKEN" "$API/releases/latest" | jq -r '.tag_name // ""' 2>/dev/null || echo "")
          else
            DESC=$(curl -s "$API" | jq -r '.description // ""' 2>/dev/null || echo "")
            LATEST=$(curl -s "$API/releases/latest" | jq -r '.tag_name // ""' 2>/dev/null || echo "")
          fi

          echo "repo_description=$DESC" >> $GITHUB_OUTPUT
          echo "latest_release=$LATEST" >> $GITHUB_OUTPUT

      - name: Detect packages (recursive) and dependencies
        id: detect_pkgs
        run: |
          set -euo pipefail
          cd plugin_repo || exit 1

          MAKEFILES=$(find . -type f -name Makefile 2>/dev/null || true)
          PKGS=""
          DEP_LIST=""

          for mk in $MAKEFILES; do
            # extract PKG_NAME (both ':=' and '=' forms), tolerate spaces
            pkg=$(grep -E '^\s*PKG_NAME\s*(:|:)?=' "$mk" 2>/dev/null | head -n1 | sed 's/.*=[[:space:]]*//' | tr -d ' ' || true)
            if [ -n "$pkg" ]; then
              PKGS="$PKGS $pkg"
            fi

            # extract DEPENDS (may include +, |, ( ), etc.)
            deps=$(grep -E '^\s*DEPENDS\s*(:|:)?=' "$mk" 2>/dev/null | sed 's/.*=[[:space:]]*//' || true)
            if [ -n "$deps" ]; then
              for token in $deps; do
                clean=$(echo "$token" | sed 's/^[+]*//g' | sed 's/[()|&]//g' | tr -d '\r' | xargs)
                [ -n "$clean" ] && DEP_LIST="$DEP_LIST $clean"
              done
            fi
          done

          # fallback: directory names under package/ if no PKG_NAME found
          if [ -z "$(echo $PKGS | xargs)" ]; then
            fallback=""
            for d in package/* package/*/* 2>/dev/null; do
              if [ -f "$d/Makefile" ]; then
                name=$(grep -E '^\s*PKG_NAME\s*(:|:)?=' "$d/Makefile" 2>/dev/null | head -n1 | sed 's/.*=[[:space:]]*//' | tr -d ' ' || true)
                [ -n "$name" ] && fallback="$fallback $name"
              fi
            done
            PKGS="$fallback"
          fi

          PKGS=$(echo $PKGS | xargs -n1 | sort -u | xargs || true)
          DEP_LIST=$(echo $DEP_LIST | xargs -n1 | sort -u | xargs || true)

          # export outputs
          echo "found_pkgs=$PKGS" >> $GITHUB_OUTPUT
          echo "found_deps=$DEP_LIST" >> $GITHUB_OUTPUT

          if [ -z "$PKGS" ]; then
            echo "Warning: No PKG_NAME discovered. Build step may fail if no PACKAGES set."
          else
            echo "Discovered packages: $PKGS"
          fi

      - name: Build with OpenWrt SDK (only plugin packages)
        uses: openwrt/gh-action-sdk@main
        env:
          ARCH: ${{ matrix.arch }}-${{ matrix.version }}
          PACKAGES: ${{ steps.detect_pkgs.outputs.found_pkgs }}
          FEEDNAME: custom
          INDEX: 1
          KEY_BUILD: ${{ secrets.KEY_BUILD || '' }}
          PRIVATE_KEY: ${{ secrets.PRIVATE_KEY || '' }}
          NO_REFRESH_CHECK: "true"

      - name: Collect ipk files & build metadata
        run: |
          set -euo pipefail
          mkdir -p output/${{ matrix.arch }}/result

          # copy ipk files only related to the discovered packages if possible
          # Find ipks under bin/packages and copy them; try to filter by package names
          PKGS="${{ steps.detect_pkgs.outputs.found_pkgs }}"
          if [ -n "$PKGS" ]; then
            for p in $PKGS; do
              # find ipk filenames containing package name
              find bin/packages -type f -name "*${p}*.ipk" -exec cp -v {} output/${{ matrix.arch }}/ \; 2>/dev/null || true
            done
          fi

          # As fallback copy any ipk under arch folder
          if [ -z "$(ls -A output/${{ matrix.arch }} 2>/dev/null | grep -E '\.ipk' || true)" ]; then
            find bin/packages -type f -name '*.ipk' -exec cp -v {} output/${{ matrix.arch }}/ \; 2>/dev/null || true
          fi

          # Write result/info.txt
          INFO=output/${{ matrix.arch }}/result/info.txt
          echo "plugin_repo: ${{ matrix.repo }}" > "$INFO"
          echo "repo_owner: ${{ matrix.owner }}" >> "$INFO"
          echo "repo_name: ${{ matrix.repo_name }}" >> "$INFO"
          echo "openwrt_version: ${{ matrix.version }}" >> "$INFO"
          echo "arch: ${{ matrix.arch }}" >> "$INFO"
          echo "packages: ${{ steps.detect_pkgs.outputs.found_pkgs }}" >> "$INFO"
          echo "dependencies: ${{ steps.detect_pkgs.outputs.found_deps }}" >> "$INFO"
          echo "commit: ${{ steps.repo_info.outputs.commit }}" >> "$INFO"
          echo "branch: ${{ steps.repo_info.outputs.branch }}" >> "$INFO"
          echo "repo_description: ${{ steps.repo_info.outputs.repo_description }}" >> "$INFO"
          echo "latest_release: ${{ steps.repo_info.outputs.latest_release }}" >> "$INFO"
          echo "build_time: $(date -u +'%Y-%m-%dT%H:%M:%SZ')" >> "$INFO"

          # Append to changelog.txt (per-arch)
          CHANGE=output/${{ matrix.arch }}/changelog.txt
          echo "==== Build: ${{ matrix.repo }} | ${{ matrix.version }} | ${{ matrix.arch }} ====" >> "$CHANGE"
          echo "Time: $(date -u +'%Y-%m-%dT%H:%M:%SZ')" >> "$CHANGE"
          echo "Commit: ${{ steps.repo_info.outputs.commit }}" >> "$CHANGE"
          echo "Branch: ${{ steps.repo_info.outputs.branch }}" >> "$CHANGE"
          echo "Packages built: ${{ steps.detect_pkgs.outputs.found_pkgs }}" >> "$CHANGE"
          echo "Dependencies (declared): ${{ steps.detect_pkgs.outputs.found_deps }}" >> "$CHANGE"
          echo "" >> "$CHANGE"

      - name: Package artifact zip
        run: |
          set -euo pipefail
          OUTDIR=output/${{ matrix.arch }}
          SAN=${{ matrix.sanitized }}
          ZIPNAME="${SAN}-${{ matrix.arch }}-${{ matrix.version }}.zip"
          pushd "$OUTDIR" >/dev/null || exit 1
          zip -r "../${ZIPNAME}" . || true
          popd >/dev/null
          echo "zip_path=output/${ZIPNAME}" >> $GITHUB_OUTPUT

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.sanitized }}-${{ matrix.arch }}-${{ matrix.version }}
          path: output/${{ matrix.sanitized }}-${{ matrix.arch }}-${{ matrix.version }}.zip
