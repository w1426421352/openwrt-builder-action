name: release-packages II

on:
  workflow_dispatch:
    inputs:
      manual_override:
        description: "manual_override: Enable manual mode? (EN: true/false; CN: 是否启用手动模式，启用后忽略 config.json)"
        required: false
        default: "false"
      manual_repos:
        description: "manual_repos: Comma-separated owner/repo list (EN: e.g. 'owner/repo,owner2/repo2'; CN: 手动模式下的仓库列表，逗号分隔)"
        required: false
        default: ""
      manual_versions:
        description: "manual_versions: Comma-separated OpenWrt versions (EN: e.g. 'openwrt-24.10'; CN: 手动模式下的版本，逗号分隔)"
        required: false
        default: ""
      manual_targets:
        description: "manual_targets: Comma-separated target arch names (EN: e.g. 'aarch64_cortex-a53,x86_64'; CN: 手动模式下的平台，逗号分隔)"
        required: false
        default: ""

jobs:
  prepare:
    name: Prepare matrix
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - name: Checkout self repo
        uses: actions/checkout@v4

      - name: Read inputs & config.json, compute lists
        id: build-matrix
        run: |
          set -euo pipefail

          # Inputs (strings) from workflow_dispatch
          MANUAL="${{ github.event.inputs.manual_override || 'false' }}"
          MANUAL_REPOS="${{ github.event.inputs.manual_repos || '' }}"
          MANUAL_VERSIONS="${{ github.event.inputs.manual_versions || '' }}"
          MANUAL_TARGETS="${{ github.event.inputs.manual_targets || '' }}"

          echo "Manual mode: $MANUAL"
          # Normalize to lower-case true/false
          MANUAL_LC=$(echo "$MANUAL" | tr '[:upper:]' '[:lower:]')

          # load config.json if exists
          if [ -f config.json ] && [ "$MANUAL_LC" != "true" ]; then
            echo "Loading config.json"
            REPOS_JSON=$(jq -r '.repos // []' config.json)
            VERSIONS_JSON=$(jq -r '.versions // []' config.json)
            TARGETS_JSON=$(jq -r '.targets // {}' config.json)
          else
            REPOS_JSON="[]"
            VERSIONS_JSON="[]"
            TARGETS_JSON="{}"
          fi

          # Helper: convert JSON array to bash list
          json_to_list() {
            echo "$1" | jq -r '.[]' 2>/dev/null || echo ""
          }

          # Determine repos_list
          if [ "$MANUAL_LC" = "true" ]; then
            if [ -z "$MANUAL_REPOS" ]; then
              echo "Error: manual mode enabled but no manual_repos provided" >&2
              exit 1
            fi
            # split by comma, trim spaces
            IFS=',' read -r -a ARR_REPOS <<< "$MANUAL_REPOS"
            repos_list=""
            for r in "${ARR_REPOS[@]}"; do
              repo_trim=$(echo "$r" | xargs)
              if [ -n "$repo_trim" ]; then
                repos_list="$repos_list $repo_trim"
              fi
            done
          else
            # from config.json
            repos_list=$(json_to_list "$REPOS_JSON" | xargs)
          fi

          # Determine versions_list
          if [ "$MANUAL_LC" = "true" ]; then
            if [ -z "$MANUAL_VERSIONS" ]; then
              echo "Error: manual mode enabled but no manual_versions provided" >&2
              exit 1
            fi
            IFS=',' read -r -a ARR_VERS <<< "$MANUAL_VERSIONS"
            versions_list=""
            for v in "${ARR_VERS[@]}"; do
              v_trim=$(echo "$v" | xargs)
              if [ -n "$v_trim" ]; then
                versions_list="$versions_list $v_trim"
              fi
            done
          else
            versions_list=$(json_to_list "$VERSIONS_JSON" | xargs)
          fi

          # Known targets (complete list - must be present in config.json per your rule)
          ALL_TARGETS=(
            "arm_cortex-a5_vfpv4"
            "arm_cortex-a7_neon-vfpv4"
            "arm_cortex-a8_vfpv3"
            "arm_cortex-a9"
            "arm_cortex-a9_vfpv3-d16"
            "arm_cortex-a9_neon"
            "arm_cortex-a15_neon-vfpv4"
            "aarch64_cortex-a53"
            "aarch64_cortex-a72"
            "aarch64_cortex-a76"
            "aarch64_generic"
            "mips_24kc"
            "mips_4kec"
            "mips_mips32"
            "mipsel_24kc"
            "mipsel_24kc_24kf"
            "mipsel_74kc"
            "mipsel_mips32"
            "mips64_octeonplus"
            "i386_pentium4"
            "x86_64"
          )

          # Determine targets_list (only selected ones)
          targets_list=""

          if [ "$MANUAL_LC" = "true" ]; then
            # manual_targets: comma separated names
            if [ -z "$MANUAL_TARGETS" ]; then
              echo "Error: manual mode enabled but no manual_targets provided" >&2
              exit 1
            fi
            IFS=',' read -r -a ARR_T <<< "$MANUAL_TARGETS"
            for t in "${ARR_T[@]}"; do
              t_trim=$(echo "$t" | xargs)
              if [ -n "$t_trim" ]; then
                targets_list="$targets_list $t_trim"
              fi
            done
          else
            # read targets from config.json (must include all keys; if missing, default false)
            for t in "${ALL_TARGETS[@]}"; do
              val=$(echo "$TARGETS_JSON" | jq -r --arg T "$t" 'if has($T) then .[$T] else false end')
              if [ "$val" = "true" ]; then
                targets_list="$targets_list $t"
              fi
            done
          fi

          # Trim leading spaces
          repos_list=$(echo $repos_list | xargs)
          versions_list=$(echo $versions_list | xargs)
          targets_list=$(echo $targets_list | xargs)

          if [ -z "$repos_list" ]; then
            echo "Error: empty repos list" >&2
            exit 1
          fi
          if [ -z "$versions_list" ]; then
            echo "Error: empty versions list" >&2
            exit 1
          fi
          if [ -z "$targets_list" ]; then
            echo "Error: empty targets list" >&2
            exit 1
          fi

          echo "Repos: $repos_list"
          echo "Versions: $versions_list"
          echo "Targets: $targets_list"

          # Build JSON matrix include array
          includes=()
          for repo in $repos_list; do
            for ver in $versions_list; do
              for arch in $targets_list; do
                owner=$(echo "$repo" | cut -d'/' -f1)
                repo_name=$(echo "$repo" | cut -d'/' -f2-)
                sanitized=$(echo "${repo}" | tr '/' '-')
                entry=$(jq -n \
                  --arg r "$repo" \
                  --arg owner "$owner" \
                  --arg repo_name "$repo_name" \
                  --arg version "$ver" \
                  --arg arch "$arch" \
                  --arg sanitized "$sanitized" \
                  '{repo:$r, owner:$owner, repo_name:$repo_name, version:$version, arch:$arch, sanitized:$sanitized}')
                includes+=("$entry")
              done
            done
          done

          # Compose final matrix JSON
          matrix_json=$(jq -n --argjson arr "$(printf '%s\n' "${includes[@]}" | jq -s '.')" '{include:$arr}')
          echo "Matrix JSON length: $(echo "$matrix_json" | jq '.include | length')"
          # expose output
          echo "matrix<<EOF" >> $GITHUB_OUTPUT
          echo "$matrix_json" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: set-matrix (noop step to expose output)
        id: set-matrix
        run: |
          echo "matrix=${{ steps.build-matrix.outputs.matrix }}" >> $GITHUB_OUTPUT

  release:
    name: Release (build)
    needs: prepare
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.prepare.outputs.matrix) }}
    steps:
      - name: Checkout self repo
        uses: actions/checkout@v4

      - name: Checkout plugin repo
        uses: actions/checkout@v4
        with:
          repository: ${{ matrix.repo }}
          path: plugin_repo

      - name: gather repo info (commit/branch/description/release)
        id: repo_info
        run: |
          set -euo pipefail
          cd plugin_repo
          COMMIT=$(git rev-parse --short HEAD || echo "")
          BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "")
          echo "commit=$COMMIT" >> $GITHUB_OUTPUT
          echo "branch=$BRANCH" >> $GITHUB_OUTPUT

          # Try to fetch repo description and latest release from GitHub API using GITHUB_TOKEN
          OWNER="${{ matrix.owner }}"
          REPO_NAME="${{ matrix.repo_name }}"
          API="https://api.github.com/repos/${OWNER}/${REPO_NAME}"
          TOKEN="${{ secrets.GITHUB_TOKEN }}"

          if [ -n "$TOKEN" ]; then
            DESC=$(curl -s -H "Authorization: token $TOKEN" "$API" | jq -r '.description // ""')
            LATEST=$(curl -s -H "Authorization: token $TOKEN" "$API/releases/latest" | jq -r '.tag_name // ""' 2>/dev/null || echo "")
          else
            DESC=$(curl -s "$API" | jq -r '.description // ""' 2>/dev/null || echo "")
            LATEST=$(curl -s "$API/releases/latest" | jq -r '.tag_name // ""' 2>/dev/null || echo "")
          fi

          echo "repo_description=$DESC" >> $GITHUB_OUTPUT
          echo "latest_release=$LATEST" >> $GITHUB_OUTPUT

      - name: detect packages (recursive) and dependencies
        id: detect_pkgs
        run: |
          set -euo pipefail
          cd plugin_repo

          # find all Makefile
          MAKEFILES=$(find . -type f -name Makefile 2>/dev/null || true)
          PKGS=""
          DEP_LIST=""

          for mk in $MAKEFILES; do
            # get PKG_NAME (allow spaces)
            pkg=$(grep -E '^PKG_NAME *:?=' "$mk" 2>/dev/null | head -n1 | awk -F'=' '{print $2}' | tr -d ' ' || true)
            if [ -n "$pkg" ]; then
              PKGS="$PKGS $pkg"
            fi

            # get DEPENDS (may be multiple lines)
            deps=$(grep -E '^DEPENDS *:?=' "$mk" 2>/dev/null | awk -F'=' '{print $2}' || true)
            if [ -n "$deps" ]; then
              # split tokens, remove leading + and other modifiers
              for token in $deps; do
                clean=$(echo "$token" | sed 's/^[+]*//g' | sed 's/[()|&]//g' | tr -d '\\n' | tr -d '\r' | xargs)
                if [ -n "$clean" ]; then
                  DEP_LIST="$DEP_LIST $clean"
                fi
              done
            fi
          done

          # unique lists
          PKGS=$(echo $PKGS | xargs -n1 | sort -u | xargs || true)
          DEP_LIST=$(echo $DEP_LIST | xargs -n1 | sort -u | xargs || true)

          if [ -z "$PKGS" ]; then
            echo "No PKG_NAME found in repo; trying fallback: look for package name from package/ directories"
            # fallback: try directory names under package/
            fallback=""
            for d in package/* package/*/* 2>/dev/null; do
              if [ -f "$d/Makefile" ]; then
                name=$(grep -E '^PKG_NAME *:?=' "$d/Makefile" 2>/dev/null | head -n1 | awk -F'=' '{print $2}' | tr -d ' ' || true)
                if [ -n "$name" ]; then
                  fallback="$fallback $name"
                fi
              fi
            done
            fallback=$(echo $fallback | xargs -n1 | sort -u | xargs || true)
            PKGS="$fallback"
          fi

          echo "found_pkgs=$PKGS" >> $GITHUB_OUTPUT
          echo "found_deps=$DEP_LIST" >> $GITHUB_OUTPUT

      - name: build with OpenWrt SDK (only plugin packages)
        env:
          OPENWRT_VERSION: ${{ matrix.version }}
          SDK_ARCH: ${{ matrix.arch }}-${{ matrix.version }}
          FEEDNAME: custom
          KEY_BUILD: ${{ secrets.KEY_BUILD }}
          PRIVATE_KEY: ${{ secrets.PRIVATE_KEY }}
          NO_REFRESH_CHECK: true
        uses: openwrt/gh-action-sdk@main
        with:
          # pass PACKAGES as space-separated PKG_NAME list discovered above
          # the action reads env.PACKAGES - to be safe we export PACKAGES via run before using the action
          # but actions inputs vary; using env works
          # We set PACKAGES below via environment injection (the action will use it)
          # See subsequent step: action will pick up env.PACKAGES
        env:
          PACKAGES: ${{ steps.detect_pkgs.outputs.found_pkgs }}
          ARCH: ${{ matrix.arch }}-${{ matrix.version }}
          INDEX: 1

      - name: collect ipk + build metadata and package outputs
        run: |
          set -euo pipefail
          mkdir -p output/${{ matrix.arch }}/result
          # Copy ipk files from expected SDK output location(s)
          # The action typically writes to bin/packages/<arch>/{custom,base,...}
          # We'll find all .ipk under bin/packages and copy them
          find bin/packages -type f -name '*.ipk' -print0 2>/dev/null | xargs -0 -I{} cp -v {} output/${{ matrix.arch }}/ || true

          # Write result/info.txt
          mkdir -p output/${{ matrix.arch }}/result
          INFOFILE=output/${{ matrix.arch }}/result/info.txt
          echo "plugin_repo: ${{ matrix.repo }}" > "$INFOFILE"
          echo "repo_owner: ${{ matrix.owner }}" >> "$INFOFILE"
          echo "repo_name: ${{ matrix.repo_name }}" >> "$INFOFILE"
          echo "openwrt_version: ${{ matrix.version }}" >> "$INFOFILE"
          echo "arch: ${{ matrix.arch }}" >> "$INFOFILE"
          echo "packages: ${{ steps.detect_pkgs.outputs.found_pkgs }}" >> "$INFOFILE"
          echo "dependencies: ${{ steps.detect_pkgs.outputs.found_deps }}" >> "$INFOFILE"
          echo "commit: ${{ steps.repo_info.outputs.commit }}" >> "$INFOFILE"
          echo "branch: ${{ steps.repo_info.outputs.branch }}" >> "$INFOFILE"
          echo "repo_description: ${{ steps.repo_info.outputs.repo_description }}" >> "$INFOFILE"
          echo "latest_release: ${{ steps.repo_info.outputs.latest_release }}" >> "$INFOFILE"
          echo "build_time: $(date -u +'%Y-%m-%dT%H:%M:%SZ')" >> "$INFOFILE"

          # Append short changelog
          CHANGELOG=output/${{ matrix.arch }}/changelog.txt
          echo "==== Build: ${{ matrix.repo }} | ${{ matrix.version }} | ${{ matrix.arch }} ====" >> "$CHANGELOG"
          echo "Time: $(date -u +'%Y-%m-%dT%H:%M:%SZ')" >> "$CHANGELOG"
          echo "Commit: ${{ steps.repo_info.outputs.commit }}" >> "$CHANGELOG"
          echo "Branch: ${{ steps.repo_info.outputs.branch }}" >> "$CHANGELOG"
          echo "Packages built: ${{ steps.detect_pkgs.outputs.found_pkgs }}" >> "$CHANGELOG"
          echo "Dependencies (declared): ${{ steps.detect_pkgs.outputs.found_deps }}" >> "$CHANGELOG"
          echo "" >> "$CHANGELOG"

      - name: package artifact zip
        run: |
          set -euo pipefail
          OUTDIR=output/${{ matrix.arch }}
          # create a zip that contains the ipks and result/info.txt and changelog.txt
          ZIPNAME="${{ matrix.sanitized }}-${{ matrix.arch }}-${{ matrix.version }}.zip"
          pushd "$OUTDIR" >/dev/null || exit 1
          zip -r "../${ZIPNAME}" . || true
          popd >/dev/null
          echo "artifact_path=output/${{ matrix.sanitized }}-${{ matrix.arch }}-${{ matrix.version }}.zip" >> $GITHUB_OUTPUT

      - name: upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.sanitized }}-${{ matrix.arch }}-${{ matrix.version }}
          path: output/${{ matrix.sanitized }}-${{ matrix.arch }}-${{ matrix.version }}.zip
