name: release-packages

on:
  workflow_dispatch:
    inputs:
      manual_override:
        description: "Manual override (if true, use manual inputs instead of config.json) / 手动覆盖（开启后使用手动输入，忽略 config.json）"
        required: true
        type: boolean
        default: false
      manual_repos:
        description: "Comma-separated owner/repo list, e.g. 'user/repo1,user/repo2' (only used if manual_override is true) / 逗号分隔的 owner/repo 列表，仅在手动模式有效"
        required: false
        type: string
      manual_versions:
        description: "Comma-separated OpenWrt versions, e.g. 'openwrt-24.10,openwrt-23.05' (only used if manual_override is true) / 逗号分隔的 OpenWrt 版本，仅在手动模式有效"
        required: false
        type: string
      manual_targets:
        description: "Comma-separated arch targets (only used if manual_override is true). Example values: aarch64_cortex-a53,x86_64 ... / 逗号分隔的平台，仅在手动模式有效。示例: aarch64_cortex-a53,x86_64 ..."
        required: false
        type: string

jobs:
  prepare:
    name: prepare matrix
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - name: Checkout self
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Read config.json (if exists)
        id: readcfg
        run: |
          # default empty
          if [ -f config.json ]; then
            echo "CONFIG_PRESENT=true" >> $GITHUB_OUTPUT
            CFG_REPOS=$(jq -r '.repos | join(",")' config.json 2>/dev/null || echo "")
            CFG_VERSIONS=$(jq -r '.versions | join(",")' config.json 2>/dev/null || echo "")
            # targets: produce comma-separated true ones
            CFG_TARGETS=$(jq -r '.targets | to_entries[] | "\(.key)=\(.value)"' config.json 2>/dev/null || true)
            echo "cfg_repos<<EOF" >> $GITHUB_OUTPUT
            echo "$CFG_REPOS" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "cfg_versions<<EOF" >> $GITHUB_OUTPUT
            echo "$CFG_VERSIONS" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "cfg_targets<<EOF" >> $GITHUB_OUTPUT
            echo "$CFG_TARGETS" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "CONFIG_PRESENT=false" >> $GITHUB_OUTPUT
            echo "cfg_repos<<EOF" >> $GITHUB_OUTPUT
            echo "" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "cfg_versions<<EOF" >> $GITHUB_OUTPUT
            echo "" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "cfg_targets<<EOF" >> $GITHUB_OUTPUT
            echo "" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          fi

      - name: Build matrix JSON
        id: set-matrix
        run: |
          # Inputs from workflow_dispatch
          MANUAL_OVERRIDE="${{ github.event.inputs.manual_override }}"
          MANUAL_REPOS="${{ github.event.inputs.manual_repos || '' }}"
          MANUAL_VERSIONS="${{ github.event.inputs.manual_versions || '' }}"
          MANUAL_TARGETS="${{ github.event.inputs.manual_targets || '' }}"

          # config.json values (from previous step outputs)
          CFG_REPOS="${{ steps.readcfg.outputs.cfg_repos }}"
          CFG_VERSIONS="${{ steps.readcfg.outputs.cfg_versions }}"
          CFG_TARGET_ENTRIES="${{ steps.readcfg.outputs.cfg_targets }}"

          # Helper: split comma and trim
          split_trim() {
            IFS=',' read -ra arr <<< "$1"
            out=""
            for e in "${arr[@]}"; do
              e=$(echo "$e" | xargs) # trim
              if [ -n "$e" ]; then
                if [ -z "$out" ]; then out="$e"; else out="$out,$e"; fi
              fi
            done
            echo "$out"
          }

          if [ "$MANUAL_OVERRIDE" = "true" ]; then
            REPOS=$(split_trim "$MANUAL_REPOS")
            VERSIONS=$(split_trim "$MANUAL_VERSIONS")
            TARGETS=$(split_trim "$MANUAL_TARGETS")
          else
            REPOS="$CFG_REPOS"
            VERSIONS="$CFG_VERSIONS"
            # parse cfg target entries e.g.: "aarch64_cortex-a53=true"
            TARGETS=""
            while IFS= read -r line; do
              [ -z "$line" ] && continue
              key=$(echo "$line" | cut -d'=' -f1)
              val=$(echo "$line" | cut -d'=' -f2)
              if [ "$val" = "true" ]; then
                if [ -z "$TARGETS" ]; then TARGETS="$key"; else TARGETS="$TARGETS,$key"; fi
              fi
            done <<EOF
$CFG_TARGET_ENTRIES
EOF
          fi

          # final defaults safety
          REPOS=$(echo "$REPOS" | sed 's/^,//; s/,$//')
          VERSIONS=$(echo "$VERSions" | sed 's/^,//; s/,$//' || true)
          TARGETS=$(echo "$TARGETS" | sed 's/^,//; s/,$//')

          # if any is empty, fail fast with helpful message
          if [ -z "$REPOS" ]; then
            echo "No repos specified. Provide via config.json or manual_repos." >&2
            exit 1
          fi
          if [ -z "$VERSIONS" ]; then
            echo "No versions specified. Provide via config.json or manual_versions." >&2
            exit 1
          fi
          if [ -z "$TARGETS" ]; then
            echo "No targets selected. Provide via config.json or manual_targets." >&2
            exit 1
          fi

          # build matrix array of objects: repo, version, arch
          IFS=',' read -ra REPO_ARR <<< "$REPOS"
          IFS=',' read -ra VER_ARR <<< "$VERSIONS"
          IFS=',' read -ra TARGET_ARR <<< "$TARGETS"

          MATRIX='{"include":['
          first=true
          for r in "${REPO_ARR[@]}"; do
            for v in "${VER_ARR[@]}"; do
              for a in "${TARGET_ARR[@]}"; do
                # sanitize spaces
                r_trim=$(echo "$r" | xargs)
                v_trim=$(echo "$v" | xargs)
                a_trim=$(echo "$a" | xargs)
                if [ "$first" = true ]; then
                  MATRIX="$MATRIX{\"repo\":\"$r_trim\",\"version\":\"$v_trim\",\"arch\":\"$a_trim\"}"
                  first=false
                else
                  MATRIX="$MATRIX,{\"repo\":\"$r_trim\",\"version\":\"$v_trim\",\"arch\":\"$a_trim\"}"
                fi
              done
            done
          done
          MATRIX="$MATRIX]}"

          echo "matrix=$MATRIX" >> $GITHUB_OUTPUT

  build:
    name: build ${{ matrix.repo }} - ${{ matrix.version }} - ${{ matrix.arch }}
    needs: prepare
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include: ${{ fromJson(needs.prepare.outputs.matrix).include }}

    env:
      OPENWRT_VERSION: ${{ matrix.version }}
      PLUGIN_REPO: ${{ matrix.repo }}
      ARCH: ${{ matrix.arch }}

    steps:
      - name: Checkout workflow repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Checkout plugin repo
        uses: actions/checkout@v4
        with:
          repository: ${{ env.PLUGIN_REPO }}
          path: plugin_repo
          fetch-depth: 1

      - name: sanitize names
        id: names
        run: |
          # sanitize for artifact naming
          SANITIZED_REPO=$(echo "${PLUGIN_REPO}" | tr '/' '-')
          echo "SANITIZED_REPO=$SANITIZED_REPO" >> $GITHUB_ENV

      - name: detect Makefiles and packages (recursive)
        id: detect
        run: |
          cd plugin_repo
          MAKEFILES=$(find . -type f -name Makefile || true)
          PKGS=""
          for mk in $MAKEFILES; do
            # extract PKG_NAME (allows spaces around :=)
            NAME=$(grep -E '^[[:space:]]*PKG_NAME[[:space:]]*:?=' "$mk" | head -n1 | awk -F':=' '{print $2}' | tr -d ' ')
            if [ -n "$NAME" ]; then
              PKGS="$PKGS $NAME"
            fi
          done
          # try alternative common variable: PKG_NAME:= or PKG_NAME:=
          # dedupe
          PKGS=$(echo $PKGS | xargs -n1 | sort -u | xargs)
          if [ -z "$PKGS" ]; then
            echo "No PKG_NAME found in any Makefile. Will attempt fallback: detect luci- or package folder names."
            # fallback: look for directories with luci-app- or package names
            FALLBACK=""
            for d in $(find . -maxdepth 3 -type d -printf '%P\n'); do
              case "$d" in
                luci-*|*/luci-*|package/*|*/package/*)
                  name=$(basename "$d")
                  FALLBACK="$FALLBACK $name"
                  ;;
              esac
            done
            FALLBACK=$(echo $FALLBACK | xargs -n1 | sort -u | xargs)
            if [ -n "$FALLBACK" ]; then
              PKGS="$FALLBACK"
            fi
          fi

          if [ -z "$PKGS" ]; then
            echo "❌ ERROR: 未能检测到任何包名 (PKG_NAME)。请检查仓库 Makefile。" >&2
            exit 1
          fi

          echo "DETECTED_PKGS=$PKGS" >> $GITHUB_OUTPUT
          echo "PACKAGES=$PKGS" >> $GITHUB_ENV
          echo "Detected packages: $PKGS"

      - name: compute package deps & build list
        id: deps
        run: |
          cd plugin_repo
          PKG_LIST="${{ steps.detect.outputs.DETECTED_PKGS }}"
          ALL_DEPS=""
          for pkg in $PKG_LIST; do
            # find Makefile that defines this package
            MK=$(grep -R --line-number --include=Makefile "^PKG_NAME.*:=" -n . | awk -F: -v p="$pkg" '$3==p{print $1":"$2":"$3}' 2>/dev/null || true)
            # fallback: search for Makefile that contains PKG_NAME:=pkg
            MK=$(grep -R --line-number --include=Makefile "PKG_NAME.*:=.*$pkg" -n . 2>/dev/null | head -n1 | cut -d: -f1 || true)
            if [ -z "$MK" ]; then
              # search all Makefiles and pick the one that mentions package name in folder name
              MK=$(grep -R --line-number --include=Makefile "PKG_NAME" -n . 2>/dev/null | head -n1 | cut -d: -f1 || true)
            fi
            if [ -n "$MK" ]; then
              DEPS_LINE=$(grep -E '^[[:space:]]*DEPENDS[[:space:]]*:?=' "$MK" || true)
              # extract package names (strip + and spaces)
              if [ -n "$DEPS_LINE" ]; then
                DEPS=$(echo "$DEPS_LINE" | sed 's/^[^:=]*[:=]*//g' | tr '+' ' ' | tr -d '[:space:]' | tr ',' ' ' )
                # only include non-empty tokens
                for d in $DEPS; do
                  [ -n "$d" ] && ALL_DEPS="$ALL_DEPS $d"
                done
              fi
            fi
          done
          ALL_DEPS=$(echo $ALL_DEPS | xargs -n1 | sort -u | xargs)
          echo "ALL_DEPS=$ALL_DEPS" >> $GITHUB_OUTPUT
          echo "ALL_DEPS_RAW=$ALL_DEPS" >> $GITHUB_ENV
          echo "Dependencies: $ALL_DEPS"

      - name: build plugin package(s) only
        id: buildpkg
        run: |
          set -euo pipefail
          cd plugin_repo
          PKG_LIST="${{ steps.detect.outputs.DETECTED_PKGS }}"
          echo "Building packages: $PKG_LIST for ${ARCH} on ${OPENWRT_VERSION}"
          # call openwrt SDK via provided action by setting PACKAGES env — the action itself does the SDK steps
          # we rely on openwrt/gh-action-sdk to drive make target package/<pkg>/compile
          echo "PKG_LIST=$PKG_LIST" > /tmp/pkgs.txt
        # no direct compile here — compilation is done by the openwrt action below via env PACKAGES

      - name: run OpenWrt SDK build
        uses: openwrt/gh-action-sdk@main
        env:
          ARCH: ${{ env.ARCH }}-${{ env.OPENWRT_VERSION }}
          FEEDNAME: custom
          PACKAGES: ${{ env.PACKAGES }}
          INDEX: 1
          KEY_BUILD: ${{ secrets.KEY_BUILD }}
          PRIVATE_KEY: ${{ secrets.PRIVATE_KEY }}
          NO_REFRESH_CHECK: true

      - name: collect ipk files and build outputs
        run: |
          mkdir -p artifacts/${{ env.SANITIZED_REPO }}/${{ env.OPENWRT_VERSION }}/${{ env.ARCH }}
          # copy plugin ipks (only from the custom feed dir) — if plugin placed under feed name 'custom'
          # attempt several common possible locations
          possible_dirs=(
            "./bin/packages/${{ env.ARCH }}/custom"
            "./bin/packages/${{ matrix.arch }}/custom"
            "./bin/packages/${{ env.ARCH }}"
            "./bin/packages"
          )
          found=0
          for d in "${possible_dirs[@]}"; do
            if [ -d "$d" ]; then
              find "$d" -name '*.ipk' -exec cp {} artifacts/${{ env.SANITIZED_REPO }}/${{ env.OPENWRT_VERSION }}/${{ env.ARCH }}/ \;
              found=1
            fi
          done
          if [ $found -eq 0 ]; then
            echo "No ipk files found in standard bin/packages locations; still proceeding to produce info files."
          fi

          # create result/info.txt and changelog.txt
          mkdir -p artifacts/${{ env.SANITIZED_REPO }}/${{ env.OPENWRT_VERSION }}/${{ env.ARCH }}/result
          INFO_FILE="artifacts/${{ env.SANITIZED_REPO }}/${{ env.OPENWRT_VERSION }}/${{ env.ARCH }}/result/info.txt"
          CHANGELOG="artifacts/${{ env.SANITIZED_REPO }}/${{ env.OPENWRT_VERSION }}/${{ env.ARCH }}/changelog.txt"

          # gather git metadata
          cd plugin_repo
          REMOTE_URL=$(git remote get-url origin || echo "")
          BRANCH=$(git rev-parse --abbrev-ref HEAD || echo "")
          COMMIT=$(git rev-parse --short HEAD || echo "")
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          LAST_COMMIT_MSG=$(git log -1 --pretty=%B | tr -d '\r' | head -c 4000 || echo "")

          cd ..

          # package list
          PKG_LIST="${{ steps.detect.outputs.DETECTED_PKGS }}"
          DEP_LIST="${{ steps.deps.outputs.ALL_DEPS }}"

          BUILD_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

          cat > "$INFO_FILE" <<EOF
plugin_repo: ${{ env.PLUGIN_REPO }}
sanitized_repo: ${{ env.SANITIZED_REPO }}
repository_url: $REMOTE_URL
branch: $BRANCH
commit: $COMMIT
last_tag: $LAST_TAG
last_commit_message: $LAST_COMMIT_MSG

openwrt_version: ${{ env.OPENWRT_VERSION }}
arch: ${{ env.ARCH }}
packages: $PKG_LIST
dependencies: $DEP_LIST
build_time_utc: $BUILD_TIME
EOF

          # changelog: add entry (append)
          cat > "$CHANGELOG" <<EOF
Build: $BUILD_TIME
Repo: ${{ env.PLUGIN_REPO }}
Sanitized: ${{ env.SANITIZED_REPO }}
Version: ${{ env.OPENWRT_VERSION }}
Arch: ${{ env.ARCH }}
Commit: $COMMIT
Packages: $PKG_LIST
Dependencies: $DEP_LIST

EOF

          # zip up artifacts for this combination
          cd artifacts
          ZIPNAME="${{ env.SANITIZED_REPO }}-${{ env.OPENWRT_VERSION }}-${{ env.ARCH }}.zip"
          zip -r "../$ZIPNAME" "${{ env.SANITIZED_REPO }}/${{ env.OPENWRT_VERSION }}/${{ env.ARCH }}" || true
          cd ..

      - name: upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.SANITIZED_REPO }}-${{ env.OPENWRT_VERSION }}-${{ env.ARCH }}
          path: |
            artifacts/${{ env.SANITIZED_REPO }}-${{ env.OPENWRT_VERSION }}-${{ env.ARCH }}.zip
            artifacts/${{ env.SANITIZED_REPO }}/${{ env.OPENWRT_VERSION }}/${{ env.ARCH }}/result/info.txt
            artifacts/${{ env.SANITIZED_REPO }}/${{ env.OPENWRT_VERSION }}/${{ env.ARCH }}/changelog.txt
