name: release-packages II

on:
  workflow_dispatch:
    inputs:
      manual_override:
        description: "Enable manual mode? (true/false) | 是否启用手动模式"
        required: true
        type: choice
        options:
          - "false"
          - "true"
        default: "false"
      config_path:
        description: "Path to config file (only used when manual mode = false)"
        required: false
        default: "config.json"
      manual_repos:
        description: "Manual mode only: comma-separated owner/repo list"
        required: false
        default: ""
      manual_versions:
        description: "Manual mode only: comma-separated versions like 24.10,23.05"
        required: false
        default: ""

jobs:
  prepare:
    name: Prepare Matrix
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.generate.outputs.matrix }}
    steps:
      - name: Checkout self
        uses: actions/checkout@v4

      - name: Generate matrix
        id: generate
        run: |
          set -euo pipefail

          MANUAL="${{ github.event.inputs.manual_override }}"
          MANUAL_REPOS="${{ github.event.inputs.manual_repos }}"
          MANUAL_VERS="${{ github.event.inputs.manual_versions }}"
          CONFIG_PATH="${{ github.event.inputs.config_path }}"

          MANUAL_LC=$(echo "$MANUAL" | tr 'A-Z' 'a-z')

          ALL_TARGETS=(
            "arm_cortex-a5_vfpv4"
            "arm_cortex-a7_neon-vfpv4"
            "arm_cortex-a8_vfpv3"
            "arm_cortex-a9"
            "arm_cortex-a9_vfpv3-d16"
            "arm_cortex-a9_neon"
            "arm_cortex-a15_neon-vfpv4"
            "aarch64_cortex-a53"
            "aarch64_cortex-a72"
            "aarch64_cortex-a76"
            "aarch64_generic"
            "mips_24kc"
            "mips_4kec"
            "mips_mips32"
            "mipsel_24kc"
            "mipsel_24kc_24kf"
            "mipsel_74kc"
            "mipsel_mips32"
            "mips64_octeonplus"
            "i386_pentium4"
            "x86_64"
          )

          repos_list=""
          versions_list=""
          targets_list=""

          if [ "$MANUAL_LC" = "true" ]; then
            IFS=',' read -ra RARR <<< "$MANUAL_REPOS"
            for r in "${RARR[@]}"; do
              x=$(echo "$r" | xargs)
              [ -n "$x" ] && repos_list="$repos_list $x"
            done

            IFS=',' read -ra VARR <<< "$MANUAL_VERS"
            for v in "${VARR[@]}"; do
              x=$(echo "$v" | xargs)
              [ -n "$x" ] && versions_list="$versions_list $x"
            done

            for t in "${ALL_TARGETS[@]}"; do
              targets_list="$targets_list $t"
            done

          else
            if [ ! -f "$CONFIG_PATH" ]; then
              echo "Config file not found: $CONFIG_PATH"
              exit 1
            fi
            repos_list=$(jq -r '.repos[] // empty' "$CONFIG_PATH" | xargs)
            versions_list=$(jq -r '.versions[] // empty' "$CONFIG_PATH" | xargs)
            TGTS_JSON=$(jq -r '.targets // {}' "$CONFIG_PATH")
            for t in "${ALL_TARGETS[@]}"; do
              v=$(echo "$TGTS_JSON" | jq -r --arg T "$t" 'if has($T) then .[$T] else false end')
              if [ "$v" = "true" ]; then
                targets_list="$targets_list $t"
              fi
            done
          fi

          [ -z "$repos_list" ] && { echo "No repos"; exit 1; }
          [ -z "$versions_list" ] && { echo "No versions"; exit 1; }
          [ -z "$targets_list" ] && { echo "No targets"; exit 1; }

          # normalize versions (pure numeric -> openwrt-XX.XX)
          norm=""
          for v in $versions_list; do
            if [[ "$v" =~ ^openwrt- ]]; then
              norm="$norm $v"
            else
              norm="$norm openwrt-$v"
            fi
          done
          versions_list=$(echo "$norm" | xargs)

          includes=()
          for repo in $repos_list; do
            owner=$(echo "$repo" | cut -d'/' -f1)
            name=$(echo "$repo" | cut -d'/' -f2-)
            sanitized=$(echo "$repo" | tr '/' '-')
            for ver in $versions_list; do
              for arch in $targets_list; do
                item=$(jq -n \
                  --arg repo "$repo" \
                  --arg owner "$owner" \
                  --arg name "$name" \
                  --arg sanitized "$sanitized" \
                  --arg ver "$ver" \
                  --arg arch "$arch" \
                  '{repo:$repo, owner:$owner, repo_name:$name, sanitized:$sanitized, version:$ver, arch:$arch}')
                includes+=("$item")
              done
            done
          done

          matrix=$(printf '%s\n' "${includes[@]}" | jq -s '{include:.}')
          # compact single-line JSON
          matrix_compact=$(echo "$matrix" | jq -c .)
          echo "matrix=$matrix_compact" >> $GITHUB_OUTPUT

  release:
    name: Build & Package
    needs: prepare
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.prepare.outputs.matrix) }}

    steps:
      - name: Checkout self
        uses: actions/checkout@v4

      - name: Checkout plugin repo
        uses: actions/checkout@v4
        with:
          repository: ${{ matrix.repo }}
          path: plugin_repo

      - name: Gather repo info
        id: repo_info
        run: |
          set -euo pipefail
          cd plugin_repo
          COMMIT=$(git rev-parse --short HEAD 2>/dev/null || true)
          BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || true)
          echo "commit=$COMMIT" >> $GITHUB_OUTPUT
          echo "branch=$BRANCH" >> $GITHUB_OUTPUT
          OWNER="${{ matrix.owner }}"
          REPO="${{ matrix.repo_name }}"
          API="https://api.github.com/repos/${OWNER}/${REPO}"
          TOKEN="${{ secrets.GITHUB_TOKEN || '' }}"
          if [ -n "$TOKEN" ]; then
            DESC=$(curl -s -H "Authorization: token $TOKEN" "$API" | jq -r '.description // ""' 2>/dev/null || echo "")
            LATEST=$(curl -s -H "Authorization: token $TOKEN" "$API/releases/latest" | jq -r '.tag_name // ""' 2>/dev/null || echo "")
          else
            DESC=$(curl -s "$API" | jq -r '.description // ""' 2>/dev/null || echo "")
            LATEST=$(curl -s "$API/releases/latest" | jq -r '.tag_name // ""' 2>/dev/null || echo "")
          fi
          echo "repo_description=$DESC" >> $GITHUB_OUTPUT
          echo "latest_release=$LATEST" >> $GITHUB_OUTPUT

      - name: Detect packages & deps
        id: detect_pkgs
        run: |
          set -euo pipefail
          cd plugin_repo
          MAKEFILES=$(find . -type f -name Makefile 2>/dev/null || true)
          PKGS=""
          DEPS=""
          for mk in $MAKEFILES; do
            p=$(grep -E '^\s*PKG_NAME\s*(:|:)?=' "$mk" 2>/dev/null | head -n1 | sed 's/.*=[[:space:]]*//' | tr -d ' ' || true)
            [ -n "$p" ] && PKGS="$PKGS $p"
            deps_raw=$(grep -E '^\s*DEPENDS\s*(:|:)?=' "$mk" 2>/dev/null | sed 's/.*=[[:space:]]*//' || true)
            if [ -n "$deps_raw" ]; then
              for tok in $deps_raw; do
                clean=$(echo "$tok" | sed 's/^[+]*//g' | sed 's/[()|&]//g' | tr -d '\r' | xargs)
                [ -n "$clean" ] && DEPS="$DEPS $clean"
              done
            fi
          done
          PKGS=$(echo $PKGS | xargs -n1 | sort -u | xargs || true)
          DEPS=$(echo $DEPS | xargs -n1 | sort -u | xargs || true)
          echo "found_pkgs=$PKGS" >> $GITHUB_OUTPUT
          echo "found_deps=$DEPS" >> $GITHUB_OUTPUT
          if [ -z "$PKGS" ]; then
            echo "Warning: no PKG_NAME discovered."
          fi

      - name: Build plugin packages
        uses: openwrt/gh-action-sdk@main
        env:
          ARCH: ${{ matrix.arch }}-${{ matrix.version }}
          PACKAGES: ${{ steps.detect_pkgs.outputs.found_pkgs }}
          INDEX: 1

      - name: Collect outputs and write metadata
        id: collect_output
        run: |
          set -euo pipefail
          ARCH="${{ matrix.arch }}"
          OUT="output/$ARCH"
          mkdir -p "$OUT"
          PKGS="${{ steps.detect_pkgs.outputs.found_pkgs }}"
          if [ -n "$PKGS" ]; then
            for p in $PKGS; do
              find bin/packages -type f -name "*${p}*.ipk" -exec cp -v {} "$OUT" \; 2>/dev/null || true
            done
          fi
          # fallback: copy any ipk if none found
          if [ -z "$(ls -A "$OUT" 2>/dev/null)" ]; then
            find bin/packages -type f -name '*.ipk' -exec cp -v {} "$OUT" \; 2>/dev/null || true
          fi
          INFO="$OUT/result-info.txt"
          echo "plugin_repo: ${{ matrix.repo }}" > "$INFO"
          echo "repo_owner: ${{ matrix.owner }}" >> "$INFO"
          echo "repo_name: ${{ matrix.repo_name }}" >> "$INFO"
          echo "openwrt_version: ${{ matrix.version }}" >> "$INFO"
          echo "arch: ${{ matrix.arch }}" >> "$INFO"
          echo "packages: ${{ steps.detect_pkgs.outputs.found_pkgs }}" >> "$INFO"
          echo "dependencies: ${{ steps.detect_pkgs.outputs.found_deps }}" >> "$INFO"
          echo "commit: ${{ steps.repo_info.outputs.commit }}" >> "$INFO"
          echo "branch: ${{ steps.repo_info.outputs.branch }}" >> "$INFO"
          echo "repo_description: ${{ steps.repo_info.outputs.repo_description }}" >> "$INFO"
          echo "latest_release: ${{ steps.repo_info.outputs.latest_release }}" >> "$INFO"
          echo "build_time: $(date -u +'%Y-%m-%dT%H:%M:%SZ')" >> "$INFO"
          ZIP="package-${{ matrix.sanitized }}-${{ matrix.arch }}-${{ matrix.version }}.zip"
          (cd output && zip -r "$ZIP" "$ARCH")
          echo "zip_path=output/$ZIP" >> $GITHUB_OUTPUT

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.sanitized }}-${{ matrix.arch }}-${{ matrix.version }}
          path: ${{ steps.collect_output.outputs.zip_path }}
