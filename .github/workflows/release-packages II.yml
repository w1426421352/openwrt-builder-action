name: release-packages II

on:
  workflow_dispatch:
    inputs:
      manual_override:
        description: "Enable manual mode? (true/false) | 是否启用手动模式"
        required: true
        type: choice
        options:
          - "false"
          - "true"
        default: "false"

      config_path:
        description: "Path to config file (only used when manual mode = false)"
        required: false
        default: "config.json"

      manual_repos:
        description: "Manual mode only: comma-separated owner/repo list"
        required: false
        default: ""

      manual_versions:
        description: "Manual mode only: comma-separated versions like 24.10,23.05"
        required: false
        default: ""


jobs:
  prepare:
    name: Prepare Matrix
    runs-on: ubuntu-latest
    outputs:
      matrix_b64: ${{ steps.generate.outputs.matrix_b64 }}

    steps:
      - name: Checkout self
        uses: actions/checkout@v4

      - name: Generate Matrix
        id: generate
        run: |
          set -euo pipefail

          MANUAL="${{ github.event.inputs.manual_override }}"
          MANUAL_REPOS="${{ github.event.inputs.manual_repos }}"
          MANUAL_VERS="${{ github.event.inputs.manual_versions }}"
          CONFIG_PATH="${{ github.event.inputs.config_path }}"

          MANUAL_LC=$(echo "$MANUAL" | tr 'A-Z' 'a-z')

          ALL_TARGETS=(
            "arm_cortex-a5_vfpv4"
            "arm_cortex-a7_neon-vfpv4"
            "arm_cortex-a8_vfpv3"
            "arm_cortex-a9"
            "arm_cortex-a9_vfpv3-d16"
            "arm_cortex-a9_neon"
            "arm_cortex-a15_neon-vfpv4"
            "aarch64_cortex-a53"
            "aarch64_cortex-a72"
            "aarch64_cortex-a76"
            "aarch64_generic"
            "mips_24kc"
            "mips_4kec"
            "mips_mips32"
            "mipsel_24kc"
            "mipsel_24kc_24kf"
            "mipsel_74kc"
            "mipsel_mips32"
            "mips64_octeonplus"
            "i386_pentium4"
            "x86_64"
          )

          repos_list=""
          versions_list=""
          targets_list=""

          if [ "$MANUAL_LC" = "true" ]; then
            # ----------------------------
            # Manual mode: repos & versions only
            # ----------------------------
            IFS=',' read -ra RARR <<< "$MANUAL_REPOS"
            for r in "${RARR[@]}"; do
              x=$(echo "$r" | xargs)
              [ -n "$x" ] && repos_list="$repos_list $x"
            done

            IFS=',' read -ra VARR <<< "$MANUAL_VERS"
            for v in "${VARR[@]}"; do
              x=$(echo "$v" | xargs)
              [ -n "$x" ] && versions_list="$versions_list $x"
            done

            # Manual mode uses ALL platforms by your request
            for t in "${ALL_TARGETS[@]}"; do
              targets_list="$targets_list $t"
            done

          else
            # ----------------------------
            # Automatic mode: read config.json
            # ----------------------------

            if [ ! -f "$CONFIG_PATH" ]; then
              echo "❌ Config file '$CONFIG_PATH' not found"
              exit 1
            fi

            # repos
            repos_list=$(jq -r '.repos[] // empty' "$CONFIG_PATH" | xargs)

            # versions
            versions_list=$(jq -r '.versions[] // empty' "$CONFIG_PATH" | xargs)

            # targets
            targets_json=$(jq -r '.targets' "$CONFIG_PATH")
            for t in "${ALL_TARGETS[@]}"; do
              v=$(echo "$targets_json" | jq -r --arg T "$t" 'if has($T) then .[$T] else false end')
              if [ "$v" = "true" ]; then
                targets_list="$targets_list $t"
              fi
            done
          fi

          # ----------------------------
          # Validation
          # ----------------------------
          [ -z "$repos_list" ] && { echo "❌ No repos"; exit 1; }
          [ -z "$versions_list" ] && { echo "❌ No versions"; exit 1; }
          [ -z "$targets_list" ] && { echo "❌ No targets"; exit 1; }

          # ----------------------------
          # Normalize versions
          # ----------------------------
          norm_versions=""
          for v in $versions_list; do
            if [[ "$v" =~ ^openwrt- ]]; then
              norm_versions="$norm_versions $v"
            else
              norm_versions="$norm_versions openwrt-$v"
            fi
          done
          versions_list=$(echo "$norm_versions" | xargs)

          # ----------------------------
          # Build final matrix
          # ----------------------------
          includes=()

          for repo in $repos_list; do
            owner=$(echo "$repo" | cut -d'/' -f1)
            name=$(echo "$repo" | cut -d'/' -f2-)
            sanitized=$(echo "$repo" | tr '/' '-')

            for ver in $versions_list; do
              for arch in $targets_list; do
                item=$(jq -n \
                  --arg repo "$repo" \
                  --arg owner "$owner" \
                  --arg name "$name" \
                  --arg sanitized "$sanitized" \
                  --arg ver "$ver" \
                  --arg arch "$arch" \
                  '{repo:$repo, owner:$owner, repo_name:$name, sanitized:$sanitized, version:$ver, arch:$arch}')
                includes+=("$item")
              done
            done
          done

          matrix=$(printf '%s\n' "${includes[@]}" | jq -s '{include:.}')
          matrix_b64=$(echo "$matrix" | base64 -w0)

          echo "matrix_b64=$matrix_b64" >> $GITHUB_OUTPUT
  release:
    name: Build Packages
    needs: prepare
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix: ${{ fromJson( fromBase64( needs.prepare.outputs.matrix_b64 ) ) }}

    steps:
      - name: Checkout self
        uses: actions/checkout@v4

      - name: Checkout plugin repo
        uses: actions/checkout@v4
        with:
          repository: ${{ matrix.repo }}
          path: plugin_repo

      - name: Extract repo metadata
        id: repo_info
        run: |
          set -euo pipefail
          cd plugin_repo

          COMMIT=$(git rev-parse --short HEAD || true)
          BRANCH=$(git rev-parse --abbrev-ref HEAD || true)

          echo "commit=$COMMIT" >> $GITHUB_OUTPUT
          echo "branch=$BRANCH" >> $GITHUB_OUTPUT

      - name: Detect packages
        id: detect_pkgs
        run: |
          set -euo pipefail
          cd plugin_repo

          MAKEFILES=$(find . -type f -name Makefile)
          PKGS=""
          for mk in $MAKEFILES; do
            p=$(grep -E '^\s*PKG_NAME\s*(:|:)?=' "$mk" | head -n1 | sed 's/.*=[[:space:]]*//' | tr -d ' ')
            [ -n "$p" ] && PKGS="$PKGS $p"
          done
          PKGS=$(echo $PKGS | xargs -n1 | sort -u | xargs || true)
          echo "found_pkgs=$PKGS" >> $GITHUB_OUTPUT

      - name: Build plugin packages
        uses: openwrt/gh-action-sdk@main
        env:
          ARCH: ${{ matrix.arch }}-${{ matrix.version }}
          PACKAGES: ${{ steps.detect_pkgs.outputs.found_pkgs }}
          INDEX: 1

      - name: Collect output
        run: |
          set -euo pipefail
          ARCH="${{ matrix.arch }}"
          OUT="output/$ARCH"
          mkdir -p "$OUT"

          find bin/packages -name '*.ipk' -exec cp {} "$OUT" \; || true

          INFO="$OUT/result-info.txt"
          echo "repo: ${{ matrix.repo }}" > "$INFO"
          echo "version: ${{ matrix.version }}" >> "$INFO"
          echo "arch: ${{ matrix.arch }}" >> "$INFO"
          echo "packages: ${{ steps.detect_pkgs.outputs.found_pkgs }}" >> "$INFO"
          echo "commit: ${{ steps.repo_info.outputs.commit }}" >> "$INFO"
          echo "branch: ${{ steps.repo_info.outputs.branch }}" >> "$INFO"

          ZIP="package-${{ matrix.sanitized }}-${{ matrix.arch }}-${{ matrix.version }}.zip"
          (cd output && zip -r "$ZIP" "$ARCH")

          echo "zip_path=output/$ZIP" >> $GITHUB_OUTPUT

      - name: Upload zip artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.sanitized }}-${{ matrix.arch }}-${{ matrix.version }}
          path: ${{ steps.collect_output.outputs.zip_path }}
